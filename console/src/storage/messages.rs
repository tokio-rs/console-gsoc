//! Types generated by gRPC "/proto/tracing.proto"
use std::{
    cmp::Ordering,
    fmt::Result,
    fmt::{Display, Formatter},
};

include!(concat!(env!("OUT_DIR"), "/tracing.rs"));

pub trait ValueContainer {
    fn value_by_name(&self, name: &str) -> Option<&value::Value>;

    fn str_by_name(&self, name: &str) -> Option<&str> {
        match self.value_by_name(name)? {
            value::Value::Str(string) => Some(string),
            _ => None,
        }
    }
    fn debug_by_name(&self, name: &str) -> Option<&DebugRecord> {
        match self.value_by_name(name)? {
            value::Value::Debug(debug) => Some(debug),
            _ => None,
        }
    }
    fn signed_by_name(&self, name: &str) -> Option<i64> {
        match self.value_by_name(name)? {
            value::Value::Signed(signed) => Some(*signed),
            _ => None,
        }
    }
    fn unsigned_by_name(&self, name: &str) -> Option<u64> {
        match self.value_by_name(name)? {
            value::Value::Unsigned(unsigned) => Some(*unsigned),
            _ => None,
        }
    }
    fn bool_by_name(&self, name: &str) -> Option<bool> {
        match self.value_by_name(name)? {
            value::Value::Boolean(boolean) => Some(*boolean),
            _ => None,
        }
    }
    fn any_by_name(&self, name: &str) -> Option<String> {
        Some(match self.value_by_name(name)? {
            value::Value::Str(string) => string.clone(),
            value::Value::Signed(i) => format!("{}", i),
            value::Value::Unsigned(u) => format!("{}", u),
            value::Value::Debug(d) => d.debug.clone(),
            value::Value::Boolean(b) => format!("{}", b),
        })
    }
}

impl ValueContainer for Event {
    fn value_by_name(&self, name: &str) -> Option<&value::Value> {
        for value in &self.values {
            if &value.field.as_ref()?.name == name {
                return value.value.as_ref();
            }
        }
        None
    }
}

impl ValueContainer for NewSpan {
    fn value_by_name(&self, name: &str) -> Option<&value::Value> {
        for value in &self.values {
            if &value.field.as_ref()?.name == name {
                return value.value.as_ref();
            }
        }
        None
    }
}

impl ValueContainer for Record {
    fn value_by_name(&self, name: &str) -> Option<&value::Value> {
        for value in &self.values {
            if &value.field.as_ref()?.name == name {
                return value.value.as_ref();
            }
        }
        None
    }
}

type V = value::Value;

impl V {
    pub fn from_u64(u: u64) -> V {
        value::Value::Unsigned(u)
    }
}

impl Eq for V {}

impl Ord for V {
    fn cmp(&self, other: &Self) -> Ordering {
        // Unordered or wrongly ordered Values will be moved to the end
        self.partial_cmp(other).unwrap_or(Ordering::Greater)
    }
}

impl PartialOrd<V> for V {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match (&self, &other) {
            (V::Signed(s), V::Signed(o)) => s.partial_cmp(o),
            (V::Unsigned(s), V::Unsigned(o)) => s.partial_cmp(o),
            (V::Boolean(s), V::Boolean(o)) => s.partial_cmp(o),
            (V::Str(s), V::Str(o)) => s.partial_cmp(o),
            (V::Debug(s), V::Debug(o)) => s.debug.partial_cmp(&o.debug),
            _ => None,
        }
    }
}

impl Display for V {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        match self {
            V::Unsigned(u) => write!(f, "{}", u),
            V::Signed(s) => write!(f, "{}", s),
            V::Boolean(b) => write!(f, "{}", b),
            V::Str(s) => write!(f, "{}", s),
            V::Debug(d) => write!(f, "{}", d.debug),
        }
    }
}
