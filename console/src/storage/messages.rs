//! Types generated by gRPC "/proto/tracing.proto"
include!(concat!(env!("OUT_DIR"), "/tracing.rs"));

impl Event {
    pub fn value_by_name(&self, name: &str) -> Option<&value::Value> {
        for value in &self.values {
            if &value.field.as_ref()?.name == name {
                return value.value.as_ref();
            }
        }
        None
    }

    pub fn str_by_name(&self, name: &str) -> Option<&str> {
        match self.value_by_name(name)? {
            value::Value::Str(string) => Some(string),
            _ => None,
        }
    }
    pub fn debug_by_name(&self, name: &str) -> Option<&DebugRecord> {
        match self.value_by_name(name)? {
            value::Value::Debug(debug) => Some(debug),
            _ => None,
        }
    }
    pub fn signed_by_name(&self, name: &str) -> Option<i64> {
        match self.value_by_name(name)? {
            value::Value::Signed(signed) => Some(*signed),
            _ => None,
        }
    }
    pub fn unsigned_by_name(&self, name: &str) -> Option<u64> {
        match self.value_by_name(name)? {
            value::Value::Unsigned(unsigned) => Some(*unsigned),
            _ => None,
        }
    }
    pub fn bool_by_name(&self, name: &str) -> Option<bool> {
        match self.value_by_name(name)? {
            value::Value::Boolean(boolean) => Some(*boolean),
            _ => None,
        }
    }
    pub fn any_by_name(&self, name: &str) -> Option<String> {
        Some(match self.value_by_name(name)? {
            value::Value::Str(string) => string.clone(),
            value::Value::Signed(i) => format!("{}", i),
            value::Value::Unsigned(u) => format!("{}", u),
            value::Value::Debug(d) => d.debug.clone(),
            value::Value::Boolean(b) => format!("{}", b),
        })
    }
}
